<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procesar Archivo</title>
    <style>
        #result {
            white-space: pre-wrap; /* Mantiene los saltos de línea y los espacios */
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto; /* Añade scroll si el contenido es muy largo */
        }
    </style>
</head>
<body>
    <h1>Procesar Archivo</h1>

    <input type="file" id="fileInput" accept=".txt" />
    <br><br>

    <label for="numberInput">Introduce el número de vecinos:</label>
    <input type="number" id="numberInput" min="1" />
    <br><br>

    <label for="optionSelect">Selecciona una opción:</label>
    <select id="optionSelect">
        <option value="CorPearson">Correlación de Pearson</option>
        <option value="DistCoseno">Distancia Coseno</option>
        <option value="DistEuclidea">Distancia Euclidiana</option>
    </select>
    <br><br>

    <label for="predictionSelect">Selecciona tipo de predicción:</label>
    <select id="predictionSelect">
        <option value="simple">Predicción Simple</option>
        <option value="diferencia">Diferencia con la Media</option>
    </select>
    <br><br>

    <button id="processButton">Procesar</button>

    <div id="result"></div> <!-- Sección para mostrar el resultado -->

    <script>
        function calcularCorrelacionPearson(x, y) {
            // Filtrar los pares válidos (mismo índice, sin NaN)
            const validPairs = x.reduce((acc, xi, i) => {
                if (!isNaN(xi) && !isNaN(y[i])) {
                    acc.push([xi, y[i]]); // Solo se añade el par si ambos son válidos
                }
                return acc;
            }, []);

            const validX = validPairs.map(pair => pair[0]);
            const validY = validPairs.map(pair => pair[1]);

            const n = validX.length;

            if (n === 0) return 0; // No hay pares válidos

            const sumX = validX.reduce((a, b) => a + b, 0);
            const sumY = validY.reduce((a, b) => a + b, 0);
            const sumXY = validX.reduce((sum, xi, i) => sum + xi * validY[i], 0);
            const sumX2 = validX.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = validY.reduce((sum, yi) => sum + yi * yi, 0);

            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

            return denominator === 0 ? 0 : numerator / denominator; // Evita división por cero
        }

        function calcularDistanciaCoseno(a, b) {
            const validPairs = a.reduce((acc, ai, i) => {
                if (!isNaN(ai) && !isNaN(b[i])) {
                    acc.push([ai, b[i]]);
                }
                return acc;
            }, []);

            const validA = validPairs.map(pair => pair[0]);
            const validB = validPairs.map(pair => pair[1]);

            const dotProduct = validA.reduce((sum, ai, i) => sum + ai * validB[i], 0);
            const magnitudeA = Math.sqrt(validA.reduce((sum, ai) => sum + ai * ai, 0));
            const magnitudeB = Math.sqrt(validB.reduce((sum, bi) => sum + bi * bi, 0));

            return (magnitudeA === 0 || magnitudeB === 0) ? 1 : 1 - (dotProduct / (magnitudeA * magnitudeB));
        }

        function calcularDistanciaEuclidiana(a, b) {
            const validPairs = a.reduce((acc, ai, i) => {
                if (!isNaN(ai) && !isNaN(b[i])) {
                    acc.push([ai, b[i]]);
                }
                return acc;
            }, []);

            const sumOfSquares = validPairs.reduce((sum, pair) => {
                const [ai, bi] = pair;
                return sum + Math.pow(ai - bi, 2);
            }, 0);

            return Math.sqrt(sumOfSquares);
        }

        document.getElementById('processButton').addEventListener('click', function() {
            const fileInput = document.getElementById('fileInput');
            const numNeighbors = parseInt(document.getElementById('numberInput').value);
            const option = document.getElementById('optionSelect').value;
            const predictionType = document.getElementById('predictionSelect').value;

            if (fileInput.files.length === 0) {
                alert('Por favor, carga un archivo.');
                return;
            }
            if (isNaN(numNeighbors) || numNeighbors < 1) {
                alert('Por favor, introduce un número de vecinos válido.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const fileContent = e.target.result.split('\n');
                const minValue = parseFloat(fileContent[0].trim());
                const maxValue = parseFloat(fileContent[1].trim());
                const matrix = fileContent.slice(2).map(line => 
                    line.trim().split(' ').map(val => val === '-' ? NaN : parseFloat(val))
                );

                let resultMessage = `Matriz original:\n${matrix.map(row => row.join(' ')).join('\n')}\n\n`;

                const predictions = calcularPredicciones(matrix, numNeighbors, option);
                const utilityMatrix = matrix.map((row, i) => 
                    row.map((value, j) => isNaN(value) ? predictions[i][j] : value)
                );
                resultMessage += `Matriz de utilidad con predicciones:\n${utilityMatrix.map(row => row.join(' ')).join('\n')}\n\n`;

                const similarityInfo = calcularSimilitudes(matrix, utilityMatrix, numNeighbors, option);
                resultMessage += similarityInfo;

                // Mostrar el resultado en el elemento div
                document.getElementById('result').textContent = resultMessage;
            };

            reader.readAsText(fileInput.files[0]);
        });

        function calcularPredicciones(matrix, numNeighbors, option) {
            return matrix.map((row, rowIndex) => 
                row.map((value, colIndex) => 
                    (isNaN(value) ? calcularValorFaltante(matrix, rowIndex * row.length + colIndex, numNeighbors, option) : value)
                )
            );
        }

        function calcularValorFaltante(matrix, index, numNeighbors, option) {
            const userIndex = Math.floor(index / matrix[0].length); 
            const itemIndex = index % matrix[0].length; 

            const similarities = [];

            for (let i = 0; i < matrix.length; i++) {
                if (i !== userIndex && matrix[i][itemIndex] !== null) {
                    let similarity;

                    if (option === 'CorPearson') {
                        similarity = calcularCorrelacionPearson(matrix[userIndex].filter(v => v !== null), matrix[i].filter(v => v !== null));
                    } else if (option === 'DistCoseno') {
                        similarity = calcularDistanciaCoseno(matrix[userIndex].filter(v => v !== null), matrix[i].filter(v => v !== null));
                    } else if (option === 'DistEuclidea') {
                        similarity = calcularDistanciaEuclidiana(matrix[userIndex].filter(v => v !== null), matrix[i].filter(v => v !== null));
                    }

                    if (!isNaN(similarity)) {
                        similarities.push({ index: i, similarity });
                    }
                }
            }

            similarities.sort((a, b) => b.similarity - a.similarity);
            const neighbors = similarities.slice(0, numNeighbors);

            let numerator = 0;
            let denominator = 0;

            for (const neighbor of neighbors) {
                const neighborValue = matrix[neighbor.index][itemIndex];
                if ((neighborValue !== null) && (!isNaN(neighborValue))) {
                    numerator += neighborValue * neighbor.similarity;
                    denominator += neighbor.similarity;
                }
            }

            return denominator === 0 ? null : parseFloat((numerator / denominator).toFixed(3));
        }

        function calcularSimilitudes(originalMatrix, utilityMatrix, numNeighbors, option) {
            let resultMessage = "Similitudes y vecinos seleccionados:\n";
            
            for (let i = 0; i < utilityMatrix.length; i++) {
                const userSimilarities = [];

                for (let j = 0; j < utilityMatrix.length; j++) {
                    if (i !== j) {
                        let similarity;

                        if (option === 'CorPearson') {
                            similarity = calcularCorrelacionPearson(utilityMatrix[i], utilityMatrix[j]);
                        } else if (option === 'DistCoseno') {
                            similarity = calcularDistanciaCoseno(utilityMatrix[i], utilityMatrix[j]);
                        } else if (option === 'DistEuclidea') {
                            similarity = calcularDistanciaEuclidiana(utilityMatrix[i], utilityMatrix[j]);
                        }

                        userSimilarities.push({ index: j, similarity });
                    }
                }

                userSimilarities.sort((a, b) => b.similarity - a.similarity);
                const neighbors = userSimilarities.slice(0, numNeighbors);

                resultMessage += `Usuario ${i + 1}: ` + neighbors.map(n => `Usuario ${n.index + 1} (${n.similarity.toFixed(3)})`).join(', ') + '\n';
            }

            return resultMessage;
        }
    </script>
</body>
</html>
